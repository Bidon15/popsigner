package opstack

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
)

// GenerateEnvExample generates the .env.example file content.
// Simplified: just POPSigner API key and L1 RPC - everything else is pre-configured.
func GenerateEnvExample(cfg *DeploymentConfig, addrs *ContractAddresses) string {
	// POPSigner endpoint
	popsignerRPC := cfg.POPSignerEndpoint
	if popsignerRPC == "" {
		popsignerRPC = "https://rpc.popsigner.com"
	}

	// Get dispute game factory address
	disputeGameFactory := addrs.DisputeGameFactoryProxy
	if disputeGameFactory == "" {
		disputeGameFactory = "<set_after_deployment>"
	}

	// Determine L1 beacon URL based on chain ID
	l1BeaconURL := "https://ethereum-sepolia-beacon-api.publicnode.com"
	if cfg.L1ChainID == 1 {
		l1BeaconURL = "https://ethereum-beacon-api.publicnode.com"
	} else if cfg.L1ChainID == 17000 {
		l1BeaconURL = "https://ethereum-holesky-beacon-api.publicnode.com"
	}

	return fmt.Sprintf(`################################################################################
#                         %s - OP Stack Configuration
################################################################################
# Generated by POPKins - https://popkins.popsigner.com
# 
# Copy this file to .env and fill in POPSIGNER_API_KEY.
# All other values are pre-configured for your chain.

################################################################################
# REQUIRED - Fill these in
################################################################################

# Your POPSigner API key (get from dashboard.popsigner.com)
POPSIGNER_API_KEY=<REQUIRED>

# L1 RPC endpoint (Alchemy, Infura, QuickNode, or self-hosted)
L1_RPC_URL=%s

# L1 Beacon API endpoint (required for op-node)
# Public nodes: https://ethereum-sepolia-beacon-api.publicnode.com (Sepolia)
#               https://ethereum-beacon-api.publicnode.com (Mainnet)
#               https://ethereum-holesky-beacon-api.publicnode.com (Holesky)
L1_BEACON_URL=%s

################################################################################
# PRE-CONFIGURED - Usually no changes needed
################################################################################

# L1 RPC type (basic, quicknode, erigon, nethermind, geth)
L1_RPC_KIND=basic

# Your L2 chain ID
CHAIN_ID=%d

# POPSigner RPC endpoint
POPSIGNER_RPC_URL=%s

# Role addresses (managed by POPSigner)
SEQUENCER_ADDRESS=%s
BATCHER_ADDRESS=%s
PROPOSER_ADDRESS=%s

# Contract addresses
DISPUTE_GAME_FACTORY_ADDRESS=%s
`,
		cfg.ChainName,
		cfg.L1RPC,
		l1BeaconURL,
		cfg.ChainID,
		popsignerRPC,
		cfg.SequencerAddress,
		cfg.BatcherAddress,
		cfg.ProposerAddress,
		disputeGameFactory,
	)
}

// GenerateBundleReadme generates the README.md for the artifact bundle.
func GenerateBundleReadme(chainName string, useAltDA bool) string {
	daDescription := "Ethereum calldata"
	if useAltDA {
		daDescription = "Celestia DA"
	}

	readme := fmt.Sprintf(`# %s OP Stack Bundle

This bundle contains everything needed to run your OP Stack rollup with %s.

## Quick Start

1. **Configure environment variables:**
`+"```bash"+`
cp .env.example .env
# Edit .env - fill in your POPSigner API key
`+"```"+`

2. **Start all services:**
`+"```bash"+`
docker compose up -d
`+"```"+`

That's it! The `+"`op-geth-init`"+` service automatically initializes the genesis state on first run.

3. **Check service health:**
`+"```bash"+`
# Check op-geth (should return block number)
curl -s http://localhost:8545 -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}'

# Check op-node (should return sync status)
curl -s http://localhost:9545 -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"optimism_syncStatus","params":[],"id":1}'
`+"```"+`

## Bundle Contents

| File | Description |
|------|-------------|
| `+"`genesis.json`"+` | L2 genesis state |
| `+"`rollup.json`"+` | Rollup configuration |
| `+"`addresses.json`"+` | Deployed L1 contract addresses |
| `+"`docker-compose.yml`"+` | Docker Compose configuration |
| `+"`jwt.txt`"+` | Engine API JWT secret |
| `+"`.env.example`"+` | Environment variable template |
`, chainName, daDescription)

	if useAltDA {
		readme += `
## Celestia DA

Your chain uses **Celestia** as the Data Availability layer via op-alt-da v0.10.0.

POPSigner manages your Celestia signing keys - no local keyring setup required!

### Funding Your Celestia Account

**Testnet (Mocha-4):**
- Your Celestia address is shown in the POPSigner dashboard
- Use the faucet: https://faucet.celestia-mocha.com/

**Mainnet:**
- Transfer TIA tokens to your Celestia address
- Ensure sufficient balance for blob fees (~0.01 TIA per blob)

### Configuration

The ` + "`CELESTIA_NAMESPACE`" + ` in your ` + "`.env`" + ` is auto-generated from your chain ID.
POPSigner handles all Celestia transaction signing via the ` + "`POPSIGNER_CELESTIA_ENDPOINT`" + `.
`
	}

	readme += `
## POPSigner Integration

This bundle uses **POPSigner** for secure transaction signing. Your keys never leave the secure enclave.

All signing operations are handled automatically:
- **Sequencer signing** - L2 block proposals
- **Batcher signing** - L1 batch submissions
- **Proposer signing** - L1 state root proposals
`
	if useAltDA {
		readme += `- **Celestia signing** - DA blob submissions
`
	}

	readme += `
### Setup

1. Log into [POPSigner Dashboard](https://dashboard.popsigner.com)
2. Navigate to your organization's keys
3. Copy the API key to your ` + "`.env`" + ` file (` + "`POPSIGNER_API_KEY`" + `)
4. Your role addresses are pre-configured in the bundle

## Data Directories

Service data is stored in bundle-relative directories:
- ` + "`./op-geth/data/`" + ` - L2 execution layer state
- Logs and metrics available on exposed ports

## Service Ports

| Service | Port | Description |
|---------|------|-------------|
| op-geth | 8545 | JSON-RPC |
| op-geth | 8546 | WebSocket |
| op-geth | 8551 | Engine API (internal) |
| op-node | 9545 | Rollup RPC |
| op-batcher | 8548 | Admin RPC |
| op-proposer | 8560 | Admin RPC |
`
	if useAltDA {
		readme += `| op-alt-da | 3100 | DA Server |
`
	}

	readme += `
## Troubleshooting

**Services not starting:**
` + "```bash" + `
docker compose logs -f op-geth
docker compose logs -f op-node
` + "```" + `

**Sequencer not producing blocks:**
- Check L1 RPC connectivity
- Verify POPSigner API key is correct
- Ensure sequencer address has L1 ETH for gas

**Batcher errors:**
- Check L1 balance for batcher address
- Verify DA layer connectivity

## Support

- [OP Stack Documentation](https://docs.optimism.io)
- [POPSigner Documentation](https://docs.popsigner.io)
- [Celestia Documentation](https://docs.celestia.org)

---
Generated by [POPKins](https://popkins.popsigner.com) Chain Bootstrapping Service
`

	return readme
}

// unwrapJSONString unwraps content that was stored for JSONB column.
// Supports two formats:
// 1. NEW: base64 wrapper {"_type":"base64","data":"..."}
// 2. LEGACY: JSON string "content..." (with PostgreSQL normalization issues)
func unwrapJSONString(data []byte) []byte {
	// Try new base64 wrapper format first
	var wrapper struct {
		Type string `json:"_type"`
		Data string `json:"data"`
	}
	if err := json.Unmarshal(data, &wrapper); err == nil && wrapper.Type == "base64" {
		decoded, err := base64.StdEncoding.DecodeString(wrapper.Data)
		if err == nil {
			return decoded
		}
	}

	// Try legacy JSON string format
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		return []byte(s)
	}

	// Legacy fallback: PostgreSQL JSONB normalized \n to real newlines, breaking JSON.
	// Manually unwrap: check for outer quotes and unescape remaining sequences.
	if len(data) >= 2 && data[0] == '"' && data[len(data)-1] == '"' {
		inner := data[1 : len(data)-1]
		result := make([]byte, 0, len(inner))
		for i := 0; i < len(inner); i++ {
			if inner[i] == '\\' && i+1 < len(inner) {
				switch inner[i+1] {
				case '"':
					result = append(result, '"')
					i++
				case '\\':
					result = append(result, '\\')
					i++
				case 't':
					result = append(result, '\t')
					i++
				case 'r':
					result = append(result, '\r')
					i++
				case 'n':
					result = append(result, '\n')
					i++
				default:
					result = append(result, inner[i])
				}
			} else {
				result = append(result, inner[i])
			}
		}
		return result
	}

	// Not a recognized format, return as-is
	return data
}
